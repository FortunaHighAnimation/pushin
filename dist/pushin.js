/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
/******/ (() => { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ "./src/index.js":
/*!**********************!*\
  !*** ./src/index.js ***!
  \**********************/
/***/ ((__unused_webpack_module, exports) => {

eval("/**\n * requestAnimationFrame polyfill by Erik MÃ¶ller. fixes from Paul Irish and Tino Zijdel\n * MIT license\n */\n(function () {\n\tvar lastTime = 0;\n\tvar vendors = ['ms', 'moz', 'webkit', 'o'];\n\tfor (var x = 0; x < vendors.length && !window.requestAnimationFrame; ++x) {\n\t\twindow.requestAnimationFrame = window[vendors[x] + 'RequestAnimationFrame'];\n\t\twindow.cancelAnimationFrame = window[vendors[x] + 'CancelAnimationFrame'] ||\n\t\t\twindow[vendors[x] + 'CancelRequestAnimationFrame'];\n\t}\n\n\tif (!window.requestAnimationFrame)\n\t\twindow.requestAnimationFrame = function (callback, element) {\n\t\t\tvar currTime = new Date().getTime();\n\t\t\tvar timeToCall = Math.max(0, 16 - (currTime - lastTime));\n\t\t\tvar id = window.setTimeout(function () {\n\t\t\t\t\tcallback(currTime + timeToCall);\n\t\t\t\t},\n\t\t\t\ttimeToCall);\n\t\t\tlastTime = currTime + timeToCall;\n\t\t\treturn id;\n\t\t};\n\n\tif (!window.cancelAnimationFrame)\n\t\twindow.cancelAnimationFrame = function (id) {\n\t\t\tclearTimeout(id);\n\t\t};\n}());\n\n/**\n * Helper function: Set up and start push-in effect on all elements\n * matching the provided selector.\n *\n * @param { string } selector\n */\nwindow.pushInStart = ( selector ) => {\n\tdocument.addEventListener('DOMContentLoaded', function () {\n\t\tconst elements = document.querySelectorAll(selector);\n\n\t\tfor (let i = 0; i < elements.length; i++) {\n\t\t\tnew pushIn( elements[i] ).start();\n\t\t}\n\t});\n}\n\n/**\n * PushIn object\n *\n * Once new object is created, it will initialize itself and\n * bind events to begin interacting with dom.\n */\nclass pushIn {\n\n\tconstructor( parent ) {\n\t\tthis.layers = [];\n\t\tthis.parent = parent || null;\n\t}\n\n\t/**\n\t * Initialize the object to start everything up.\n\t */\n\t start() {\n\t\tif ( this.parent ) {\n\t\t\tthis.appendStyles();\n\t\t\tthis.scrollPos = window.pageYOffset;\n\t\t\tthis.getLayers();\n\t\t\tthis.bindEvents();\n\t\t} else {\n\t\t\tconsole.error( 'No parent element provided to pushIn.js. Effect will not be applied.' );\n\t\t}\n\t}\n\n\t/**\n\t * Find all layers on the page and store them with their parameters\n\t */\n\t getLayers() {\n\t\tconst layers = this.parent.getElementsByClassName('layer');\n\t\tif ( layers ) {\n\t\t\tfor (let i = 0; i < layers.length; i++) {\n\t\t\t\tconst elem = layers[i];\n\t\n\t\t\t\tconst inpoint  = elem.dataset.hasOwnProperty( 'pushinFrom' ) ? elem.dataset.pushinFrom : null;\n\t\t\t\tconst outpoint = elem.dataset.hasOwnProperty( 'pushinTo' ) ? elem.dataset.pushinTo : null;\n\t\t\t\tconst speed    = elem.dataset.hasOwnProperty( 'pushinSpeed' ) ? elem.dataset.pushinSpeed : null;\n\t\n\t\t\t\tlet top = this.parent.getBoundingClientRect().top;\n\t\t\t\tif ( this.parent.dataset.hasOwnProperty('pushinFrom') ) {\n\t\t\t\t\ttop = this.parent.dataset.pushinFrom;\n\t\t\t\t}\n\t\n\t\t\t\tlet bottom = this.parent.getBoundingClientRect().bottom;\n\t\t\t\tif ( this.parent.dataset.hasOwnProperty('pushinTo') ) {\n\t\t\t\t\tbottom = this.parent.dataset.pushinTo;\n\t\t\t\t}\n\n\t\t\t\tconst layer = {\n\t\t\t\t\telem : elem,\n\t\t\t\t\tindex: i,\n\t\t\t\t\toriginalScale: this.getElementScaleX( elem ),\n\t\t\t\t\tparams: {\n\t\t\t\t\t\tinpoint  : (inpoint || top),\n\t\t\t\t\t\toutpoint : (outpoint || bottom),\n\t\t\t\t\t\tspeed    : (speed || 8)\n\t\t\t\t\t}\n\t\t\t\t};\n\n\t\t\t\tthis.layers.push( layer );\n\t\t\t\tthis.setZIndex( layer, layers.length );\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Set the z-index of each layer so they overlap correctly.\n\t *\n\t * @param {object} layer\n\t * @param {int} total\n\t */\n\tsetZIndex( layer, total ) {\n\t\tlayer.elem.style.zIndex = total - layer.index;\n\t}\n\n\t/**\n\t * Bind event listeners to watch for page load and user interaction.\n\t */\n\tbindEvents() {\n\t\twindow.addEventListener(\"scroll\", function (event) {\n\t\t\tthis.scrollPos = window.pageYOffset;\n\t\t\tthis.dolly();\n\t\t}.bind(this));\n\n\t\twindow.addEventListener(\"touchstart\", function (event) {\n\t\t\tthis.touchStart = event.changedTouches[0].screenY;\n\t\t}.bind(this));\n\n\t\twindow.addEventListener(\"touchmove\", function (event) {\n\t\t\tevent.preventDefault();\n\n\t\t\tconst touchMove = event.changedTouches[0].screenY;\n\t\t\tthis.scrollPos = Math.max(this.scrollEnd + this.touchStart - touchMove, 0);\n\t\t\tthis.scrollPos = Math.min(this.scrollPos, this.pageHeight - window.innerHeight);\n\n\t\t\tdolly();\n\t\t}.bind(this));\n\n\t\twindow.addEventListener(\"touchend\", function (event) {\n\t\t\tthis.scrollEnd = this.scrollPos;\n\t\t}.bind(this));\n\t}\n\n\t/**\n\t * Get the initial scale of the element at time of DOM load.\n\t *\n\t * @param {Element} elem \n\t * @return {Number} scaleX\n\t */\n\tgetElementScaleX(elem) {\n\t\tconst transform = window.getComputedStyle( elem ).getPropertyValue( 'transform' );\n\n\t\tlet scaleX = 1;\n\t\tif ( transform && transform !== 'none' ) {\n\t\t\tvar match = transform.match( /[matrix|scale]\\(([\\d,\\.\\s]+)/ );\n\t\t\tif ( match && match[1] ) {\n\t\t\t\tvar matrix = match[1].split( ', ' );\n\t\t\t\tscaleX = parseFloat(matrix[0]);\n\t\t\t}\n\t\t}\n\n\n\t\treturn scaleX;\n\t}\n\n\t/**\n\t * Animation effect, mimicking a camera dolly on the webpage.\n\t */\n\tdolly() {\n\t\trequestAnimationFrame(function () {\n\t\t\tthis.layers.forEach( function( layer ) {\n\t\t\t\tif ( this.isActive( layer ) ) {\n\t\t\t\t\tlayer.elem.classList.remove('hide');\n\t\t\t\t\tthis.setScale( layer.elem, this.getScaleValue( layer ) );\n\t\t\t\t} else if ( this.shouldHide( layer ) ) {\n\t\t\t\t\tlayer.elem.classList.add('hide');\n\t\t\t\t}\n\t\t\t}.bind(this));\n\t\t}.bind(this));\n\t}\n\n\t/**\n\t * Whether or not a layer should currently be zooming.\n\t *\n\t * @param {Object} layer \n\t * @returns Boolean\n\t */\n\tisActive( layer ) {\n\t\treturn this.scrollPos >= layer.params.inpoint && this.scrollPos <= layer.params.outpoint;\n\t}\n\n\t/**\n\t * Whether or not a layer should be hidden\n\t *\n\t * @param {Object} layer \n\t * @returns Boolean\n\t */\n\tshouldHide( layer ) {\n\t\tlet hide = true;\n\n\t\tconst isFirst = layer.index === 0;\n\t\tconst isLast  = layer.index + 1 === this.layers.length;\n\n\t\tif ( isFirst && this.scrollPos < layer.params.inpoint ) {\n\t\t\thide = false;\n\t\t} else if ( isLast && this.scrollPos > layer.params.outpoint ) {\n\t\t\t// If this is the last layer and we have scrolled past the bottom of the parent, it should be visible\n\t\t\thide = false;\n\t\t} else if ( ! isFirst && ! isLast & this.isActive( layer )) {\n\t\t\thide = false;\n\t\t}\n\t\treturn hide;\n\t}\n\n\t/**\n\t * Get the scaleX value for the layer.\n\t *\n\t * @param {Object} layer \n\t * @return {Number}\n\t */\n\tgetScaleValue(layer) {\n\t\tconst distance = this.scrollPos - layer.params.inpoint;\n\t\tconst speed    = Math.min( layer.params.speed, 100 ) / 100;\n\t\tconst delta    = ( distance * speed ) / 100;\n\n\t\treturn Math.max( layer.originalScale + delta, 0 );\n\t}\n\n\t/**\n\t * Set element scale.\n\t *\n\t * @param {HtmlElement} elem \n\t * @param {Number} value \n\t */\n\tsetScale( elem, value ) {\n\t\tconst scaleString = \"scale(\" + value + \")\";\n\t\telem.style.webkitTransform = scaleString;\n\t\telem.style.mozTransform = scaleString;\n\t\telem.style.msTransform = scaleString;\n\t\telem.style.oTransform = scaleString;\n\t\telem.style.transform = scaleString;\n\t}\n\n\t/**\n\t * Add a few simple CSS styles to the page for functionality.\n\t */\n\tappendStyles() {\n\t\tlet stylesheet = document.getElementById( 'pushinStyles' );\n\t\tif ( ! stylesheet ) {\n\t\t\tstylesheet = document.createElement( 'style' );\n\t\t\tstylesheet.id = 'pushinStyles';\n\t\t\tstylesheet.innerText = \".hide{ opacity: 0 !important; } .layer { width: 100%; height: 100%; transition: opacity 1000ms ease; position: fixed; }\";\n\n\t\t\tdocument.head.appendChild( stylesheet )\n\t\t}\n\t}\n}\n\nexports.pushIn = pushIn;\n\n//# sourceURL=webpack://pushin/./src/index.js?");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module can't be inlined because the eval devtool is used.
/******/ 	var __webpack_exports__ = {};
/******/ 	__webpack_modules__["./src/index.js"](0, __webpack_exports__);
/******/ 	
/******/ })()
;