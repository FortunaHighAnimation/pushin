/*!
 * Pushin.js - v4.0.2
 * Author: Nathan Blair <nate@natehub.net> (https://natehub.net)
 * License: MIT
 */ !(function () {
  'use strict';
  class t {
    constructor(t, e) {
      var s, n, i;
      (this.container = t),
        (this.scrollY = 0),
        (this.scrollEnd = null),
        (this.touchStart = null),
        (this.pageHeight = null),
        (this.layers = []),
        (this.speedDelta = 100),
        (this.transitionLength = 200),
        (this.layerDepth = 1e3),
        (this.lastAnimationFrameId = -1),
        (this.cleanupFns = []),
        (this.debug =
          null !== (s = null == e ? void 0 : e.debug) && void 0 !== s && s),
        (this.layerOptions =
          null !== (n = null == e ? void 0 : e.layers) && void 0 !== n
            ? n
            : []),
        (this.sceneOptions =
          null !== (i = null == e ? void 0 : e.scene) && void 0 !== i
            ? i
            : { breakpoints: [], inpoints: [] });
    }
    start() {
      this.container
        ? ((this.scrollY = this.getScrollY()),
          this.debug && this.showDebugger(),
          this.addScene(),
          this.setBreakpoints(),
          this.getLayers(),
          this.setScrollLength(),
          'undefined' != typeof window && this.bindEvents(),
          this.toggleLayers())
        : console.error(
            'No container element provided to pushIn.js. Effect will not be applied.'
          );
    }
    destroy() {
      for (
        cancelAnimationFrame(this.lastAnimationFrameId);
        this.cleanupFns.length;

      )
        this.cleanupFns.pop()();
    }
    getScrollY() {
      return 'undefined' != typeof window ? window.scrollY : 0;
    }
    addScene() {
      const t = this.container.querySelector('.pushin-scene');
      t
        ? (this.scene = t)
        : ((this.scene = document.createElement('div')),
          this.scene.classList.add('pushin-scene'),
          (this.scene.innerHTML = this.container.innerHTML),
          (this.container.innerHTML = ''),
          this.container.appendChild(this.scene),
          this.cleanupFns.push(() => this.container.removeChild(this.scene)));
    }
    setBreakpoints() {
      0 === this.sceneOptions.breakpoints.length &&
        (this.sceneOptions.breakpoints = [768, 1440, 1920]),
        this.scene.dataset.pushinBreakpoints &&
          (this.sceneOptions.breakpoints = this.scene.dataset.pushinBreakpoints
            .split(',')
            .map(t => parseInt(t.trim(), 10))),
        this.sceneOptions.breakpoints.unshift(0);
    }
    getLayers() {
      const t = Array.from(
        this.container.getElementsByClassName('pushin-layer')
      );
      for (let e = 0; e < t.length; e++) {
        const s = t[e],
          n = this.getInpoints(s, e),
          i = this.getOutpoints(s, n[0], e),
          o = this.getSpeed(s, e),
          r = {
            element: s,
            index: e,
            originalScale: this.getElementScaleX(s),
            ref: { inpoints: n, outpoints: i, speed: o },
            params: {
              inpoint: this.getInpoint(n),
              outpoint: this.getOutpoint(i),
              speed: o,
            },
          };
        this.layers.push(r), this.setZIndex(r, t.length);
      }
    }
    getInpoints(t, e) {
      var s, n;
      const { top: i } = this.scene.getBoundingClientRect();
      let o = [i];
      if (t.dataset.pushinFrom)
        o = t.dataset.pushinFrom.split(',').map(t => parseInt(t.trim(), 10));
      else if (
        null === (s = this.layerOptions[e]) || void 0 === s
          ? void 0
          : s.inpoints
      )
        o = this.layerOptions[e].inpoints;
      else if (0 === e && this.scene.dataset.pushinFrom)
        o = this.scene.dataset.pushinFrom
          .split(',')
          .map(t => parseInt(t.trim(), 10));
      else if (
        0 === e &&
        (null === (n = this.sceneOptions) || void 0 === n
          ? void 0
          : n.inpoints.length) > 0
      )
        o = this.sceneOptions.inpoints;
      else if (e > 0) {
        const { outpoint: t } = this.layers[e - 1].params;
        o = [t - this.speedDelta];
      }
      return o;
    }
    getOutpoints(t, e, s) {
      var n;
      let i = [e + this.layerDepth];
      if (t.dataset.pushinTo) {
        i = t.dataset.pushinTo.split(',').map(t => parseInt(t.trim(), 10));
      } else
        (null === (n = this.layerOptions[s]) || void 0 === n
          ? void 0
          : n.outpoints) && (i = this.layerOptions[s].outpoints);
      return i;
    }
    getSpeed(t, e) {
      var s;
      let n = null;
      return (
        t.dataset.pushinSpeed
          ? ((n = parseInt(t.dataset.pushinSpeed, 10)),
            Number.isNaN(n) && (n = 8))
          : 'number' == typeof e &&
            (null === (s = this.layerOptions[e]) || void 0 === s
              ? void 0
              : s.speed) &&
            (n = this.layerOptions[e].speed),
        n || 8
      );
    }
    getBreakpointIndex() {
      const t = 'undefined' != typeof window ? window.innerWidth : 0,
        e = this.sceneOptions.breakpoints.reverse().findIndex(e => e <= t);
      return -1 === e ? 0 : this.sceneOptions.breakpoints.length - 1 - e;
    }
    setZIndex(t, e) {
      t.element.style.zIndex = (e - t.index).toString();
    }
    bindEvents() {
      const t = () => {
        (this.scrollY = this.getScrollY()), this.dolly();
      };
      window.addEventListener('scroll', t),
        this.cleanupFns.push(() => window.removeEventListener('scroll', t));
      const e = t => {
        this.touchStart = t.changedTouches[0].screenY;
      };
      window.addEventListener('touchstart', e),
        this.cleanupFns.push(() => window.removeEventListener('touchstart', e));
      const s = t => {
        t.preventDefault();
        const e = t.changedTouches[0].screenY;
        (this.scrollY = Math.max(this.scrollEnd + this.touchStart - e, 0)),
          (this.scrollY = Math.min(
            this.scrollY,
            this.pageHeight - window.innerHeight
          )),
          this.dolly();
      };
      window.addEventListener('touchmove', s),
        this.cleanupFns.push(() => window.removeEventListener('touchmove', s));
      const n = () => {
        this.scrollEnd = this.scrollY;
      };
      let i;
      window.addEventListener('touchend', n),
        this.cleanupFns.push(() => window.removeEventListener('touchend', n));
      const o = () => {
        clearTimeout(i),
          (i = window.setTimeout(() => {
            this.resetLayerParams(),
              this.setScrollLength(),
              this.toggleLayers();
          }, 300));
      };
      window.addEventListener('resize', o),
        this.cleanupFns.push(() => window.removeEventListener('resize', o)),
        this.pushinDebug &&
          window.addEventListener('scroll', () => {
            var t;
            const e = 'undefined' != typeof window ? window.scrollY : 0,
              s =
                null === (t = this.pushinDebug) || void 0 === t
                  ? void 0
                  : t.querySelector('.pushin-debug__content');
            s && (s.textContent = `Scroll position: ${Math.round(e)}px`);
          });
    }
    resetLayerParams() {
      this.layers.forEach(t => {
        t.params = {
          inpoint: this.getInpoint(t.ref.inpoints),
          outpoint: this.getOutpoint(t.ref.outpoints),
          speed: t.ref.speed,
        };
      });
    }
    getElementScaleX(t) {
      const e = window.getComputedStyle(t).getPropertyValue('transform');
      let s = 1;
      if (e && 'none' !== e) {
        const t = e.match(/[matrix|scale]\(([\d,.\s]+)/);
        if (t && t[1]) {
          const e = t[1].split(', ');
          s = parseFloat(e[0]);
        }
      }
      return s;
    }
    dolly() {
      cancelAnimationFrame(this.lastAnimationFrameId),
        (this.lastAnimationFrameId = requestAnimationFrame(() => {
          this.toggleLayers();
        }));
    }
    toggleLayers() {
      this.layers.forEach(t => this.setLayerStyle(t));
    }
    isActive(t) {
      const { inpoint: e } = t.params,
        { outpoint: s } = t.params;
      return this.scrollY >= e && this.scrollY <= s;
    }
    getInpoint(t) {
      return t[this.getBreakpointIndex()] || t[0];
    }
    getOutpoint(t) {
      return t[this.getBreakpointIndex()] || t[0];
    }
    getScaleValue(t) {
      const e =
        ((this.scrollY - t.params.inpoint) *
          (Math.min(t.params.speed, 100) / 100)) /
        100;
      return Math.max(t.originalScale + e, 0);
    }
    setScale({ style: t }, e) {
      const s = `scale(${e})`;
      (t.webkitTransform = s),
        (t.mozTransform = s),
        (t.msTransform = s),
        (t.oTransform = s),
        (t.transform = s);
    }
    setLayerStyle(t) {
      let e = 0;
      const s = 0 === t.index,
        n = t.index + 1 === this.layers.length,
        { inpoint: i } = t.params,
        { outpoint: o } = t.params;
      if (s && this.scrollY < i) e = 1;
      else if (n && this.scrollY > o) e = 1;
      else if (this.isActive(t)) {
        this.setScale(t.element, this.getScaleValue(t));
        let r =
          Math.max(Math.min(this.scrollY - i, this.transitionLength), 0) /
          this.transitionLength;
        s && (r = 1);
        let a =
          Math.max(Math.min(o - this.scrollY, this.transitionLength), 0) /
          this.transitionLength;
        n && (a = 1), (e = Math.min(r, a));
      }
      t.element.style.opacity = e.toString();
    }
    setScrollLength() {
      const t = getComputedStyle(this.container).height.replace('px', ''),
        e = (this.layers.length - 1) * this.speedDelta,
        s = this.layers.length * (this.layerDepth + this.transitionLength);
      this.container.style.height = `${Math.max(parseFloat(t), s - e)}px`;
    }
    showDebugger() {
      (this.pushinDebug = document.createElement('div')),
        this.pushinDebug.classList.add('pushin-debug');
      const t = document.createElement('p');
      (t.innerText = 'Pushin.js Debugger'),
        t.classList.add('pushin-debug__title');
      const e = 'undefined' != typeof window ? window.scrollY : 0,
        s = document.createElement('div');
      s.classList.add('pushin-debug__content'),
        (s.innerText = `Scroll position: ${e}px`),
        this.pushinDebug.appendChild(t),
        this.pushinDebug.appendChild(s),
        document.body.appendChild(this.pushinDebug);
    }
  }
  const e = e => {
    const s = null != e ? e : {},
      n = document.querySelectorAll('.pushin'),
      i = [];
    for (const e of n) {
      const n = new t(e, s);
      n.start(), i.push(n);
    }
    return i;
  };
  'undefined' != typeof window && (window.pushInStart = e);
})();
